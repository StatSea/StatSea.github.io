---
layout: single
title: "[DS] 스택2"
categories: [DS]
tags: [DS]
---
스택에 대한 설명

---

# 스택 응용 : 수식의 계산
- 컴퓨터에서 컴파일러의 수식 계산 순서
- 중위 표기식 (소스코드) -> 후위 표기식 (컴파일러) -> 계산
- 2 + 3*4 -> 2 3 4 * + -> 14

# 구현시 고려해야 할 사항 
- 스택에 저장할 내용은 피연산자(실수)
  - 피연산자 스택을 만들기

- 입력에 대한 처리
  - 문자 단위로 입력받는 경우 (getc()) 는 연산자는 문제없지만 피연산자는 여러 문자가 하나의 숫자가 되는 경우가 발생
  - 처리 방법 : ungetc() 이용
    - ungetc() : 방금 읽어온 문자를 바로 활용 x , 다시 읽을 수 있게 해줌

## 피연산자 수식 클래스
```python
#define MAX_STACK_SIZE 100
inline void error( char* str ) {…};
class OperandStack {
  double data[MAX_STACK_SIZE];
  int top;
public:
  OperandStack() { top = -1; }
  bool isEmpty() { return top == -1; }
  bool isFull() { return top == MAX_STACK_SIZE-1; }
  void push(double e) {
    if( isFull() ) error("스택 포화 에러");
    data[++top] = e;
  }
  double pop( ) {
    if( isEmpty() ) error("스택 공백 에러");
    return data[top--];
  }
};

```

## 알고리즘 구현 : 후위수식 계산 함수
```python
# include OperandStack.h
double calcPostfixExpr( FILE *fp = stdin ) { # 매개 변수가 없으면 키보드에서 입력 받기
  char c;
  double val;
  OperandStack st;
  while ( (c=getc(fp)) != '\n' ) {
    if( c=='+' || c=='-' || c=='*' || c=='/＇ ){ //연산자인 경우
      double val2 = st.pop();
      double val1 = st.pop();
      switch( c ) {
        case '+': st.push(val1 + val2); break;
        case '-': st.push(val1 - val2); break;
        case '*': st.push(val1 * val2); break;
        case '/': st.push(val1 / val2); break;
        }
  }
  else if (c>='0' && c<='9＇) { //피연산자인 경우
    ungetc( c, fp );
    fscanf( fp, "%lf", &val );
    st.push( val );
   }
 }
return (st.pop());
}
```
- switch = 여러 경우(case)에 따라 다른 동작을 하게 하는 조건문

```python
# 테스트 프로그램
int main() {
  printf("수식 입력 (Postfix)= ");
  double res = calcPostfixExpr();
  printf("계산 결과 => %f\n", res);
  return 0;
}
```

# 중위 표기 수식의 후위 표기 변환
- 중위표기와 후위표기
  - 공통점 : 피연산자의 순서가 동일
  - 다른점 : 연산자들의 순서가 다름
    - 연산자만 스택에 저장했다가 출력

- 알고리즘
  1. 입력수식을 하나씩 스캔
  2. 피연산자를 만나면 그대로 출력
  3. 연산자를 만나면 스택의 연산자와 비교하여 우선순위 결정
  4. 입력 op가 스택 op보다 같거나 낮으면 pop , 입력 op를 스택에 push
  5. 높은 경우 입력 op를 push
  6. 왼쪽 괄호는 스택에 push
  7. 오른쪽 괄호는 스택에서 왼쪽 괄호위에 쌓여있는 모든 연산자 출력
 
![image](https://github.com/user-attachments/assets/32b1b803-6270-4583-b7b2-b0b71517fb08)

![image](https://github.com/user-attachments/assets/57058a80-4d34-4091-8e4c-bb444b4752e9)

# 알고리즘 구현

```python
# include “ArrayStack.h”
void infix2Postfix( FILE *fp = stdin )
{
  char c, op;
  double val;
  ArrayStack st;
  while ( (c=getc(fp)) != '\n' ) {
    if ((c>='0' && c<='9')) { # 피연산자인 경우
      ungetc( c, fp ); # 소수도 포함하기 위해서
      fscanf( fp, "%lf", &val );
      printf("%4.1f ", val);
      }
   }
  else if( c=='(' ) st.push( c ); # 왼쪽 괄호인 경우
  else if( c==')' ) { # 오른쪽 괄호인 경우
    while (!st.isEmpty()) {
      op = st.pop();
      if( op== '(' ) break;
      else printf( "%c ", op );
  else if( c=='+' || c=='-' || c=='*' || c=='/＇ ){ //연산자인 경우
    while ( !st.isEmpty() ) {
      op = st.peek();
      if (precedence(op) >= precedence(c)) {
        printf( "%c ", op );
        st.pop();
      }
      else break;
   }
  st.push( c );
  }
}
while (!st.isEmpty())
  printf( "%c ", st.pop() );
}
}
```
```python
int precedence( char op ) {
    switch (op) {
        case '(' : case ')' : return 0;
        case '+' : case '-' : return 1;
        case '*' : case '/' : return 2;
    }
  return -1;
}
```

# 스택 응용 : 미로 탐색 문제
- 스택을 이용한 탐색
  - 깊이 우선 탐색 : DFS
    - 탐색을 시작한 방향에 따라 그 방향을 끝까지 우선적으로 탐색하고, 더이상 탐색할 곳이 없으면 되돌아 가서 다른 방향을 탐색

# 2차원 좌표 클래스
- 스택에 2차원 좌표가 들어가야 한다.
```python
struct Location2D {
    int row; // 현재 위치의 행 번호
    int col; // 현재 위치의 열 번호
    Location2D ( int r=0, int c=0 ) { row = r; col = c; }

    // 위치 p가 자신의 이웃인지 검사하는 함수
    bool isNeighbor( Location2D &p ) {
        return( (row==p.row && (col==p.col-1 || col==p.col+1)) || # row는 같은데 위냐 아래냐
        (col==p.col && (row==p.row-1 || row==p.row+1)) ); # col은 같은데 왼, 오냐
    }

    // p가 자신과 같은 위치인지를 검사(연산자 오버로딩 사용)
    bool operator==( Location2D &p ) {
        return row==p.row && col==p.col;
    }
};
```


