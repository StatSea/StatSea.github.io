---
layout: single
title: "[DS] 배열과 클래스"
categories: [DS]
tags: [DS]
---
배열과 클래스 설명

---

# 배열
- 같은 형의 변수를 어러 개 만드는 경우에 사용
- 변수 선언 : int a0, a1, a2;
- 배열 선언 : int a[3];

## 배열의 추상 자료형 (ADT)
- 배열 : <인덱스, 요소> 쌍의 집합
- 인덱스가 주어지면 해당되는 요소가 대응되는 구조

```python
# 데이터 : <인덱스, 요소> 쌍의 집합
# 연산
# - create(n) : n개의 요소를 가진 배열의 생성
# - retrieve(i) : 배열의 i번째 요소 반환
# - store(i,item) : 배열의 i번째 위치에 item 저장
```

- 이런 것들이 가능하게 하려면 세부적으로 코딩해야 한다.
---

## 1차원 배열
- 자료형 배열이름 [배열의 크기];
  - 예 : int A[6];
  - sizeof(int) : 컴파일러와 시스템 아키텍쳐에 따라 달라질 수 있음
![image](https://github.com/user-attachments/assets/58aa8e14-1e7f-446a-9c2b-c6353c62aa38)

## 1차원 배열 예시 : 문자열
- char s[12] = "game over";
- 하나의 문자 -> 작은 따옴표
- 문자열 -> 큰 따옴표

![image](https://github.com/user-attachments/assets/111b7318-a204-4961-9e97-26175f0d3309)

- 문자열 처리
  - <string.h> , <cstring>
  - strcpy() : 복사
  - strcmp() : 비교
  - 해당 라이브러리는 문자열의 비교나 복사를 위해 = == < 사용 불가능

---

## 2차원 배열
- 자료형 배열이름 [행의 크기][열의 크기]
  - 예시 : int A[4][3];

## 함수의 매개변수로서의 배열
- 변수의 전달 -> 값을 복사
- 배열의 전달 -> 배열 첫 번째 항목의 주소를 전달

```python
void copy_array(int a[], int b[],int len){
    int i;
    for (i=0; i<len; i++)
        b[i] = a[i];
}

void copy_variable(int a, int b) {
    b = a;
}

int A[5] = {10,20,30};
int B[5] , i, x=2028 , y=0;
copy_array(A,B,5);
copy_varaiable(x,y);
```

- 결과는 어떻게 나왔을까?
  - 배열은 그대로 복사가 되었고 변수는 복사가 되지 않았다.
  - 배열만 가능한 이유 : 배열은 값복사가 아니라 주소복사여서

## 배열에서의 주의사항
- 함수의 매개변수 / 파라미터로서의 배열
  - 함수 안에서 매개변수로 배열을 받아서 내용을 수정하면, 원래의 배열이 수정된다.
  - 배열 이름이 포인터 역할이기 때문
 
```python
void sub(int x, int arr[]){
    x = 10;
    arr[0] = 10;
}
void main()
{
    int var = 0, list[MAX_SIZE];
    list[0] = 0;
    sub(var, list);
}
```
- var, list[0] 출력 결과는?
  - var = 0, list[0] = 10
  - 배열이라 가능한 것! 변수는 지역변수라 불가능하다.
---

- 매개변수로 배열의 길이도 전달해야한다.

```python
int findMaxValue(int a[], int len) {
    int max = a[0];
    for (int i = 1; i < len; i++) {
        if (a[i] > max)
            max = a[i];
    }
    return max;
}

int arr[10] = {3,24,82,12,34,7,53,17,26,51};
int maxVal = findMaxValue(arr,10);
```
- 2차원 이상의 다차원배열의 매개변수 전달은 조심해야한다.
- 최소한 열 크기 정보는 지정하기
```python
int findMaxPixel( int a[][5], int h, int w)
```
- 하지만 위와 같은 경우는 활용성이 제한적이므로 동적 할당이 필요하다.

---

# 클래스

## 구조체
- 기존의 자료형들을 조합해 새로운 자료형을 만드는 방법
- 배열과의 차이
  - 배열 : 타입이 같은 데이터들을 하나로 묶음
  - 구조체 : 타입이 다른 데이터들을 하나로 묶음

## 구조체의 정의와 선언
- 정의
```python
struct Student{
  int id;
  char name[20];
  double score;
};

- 선언
```python
Student a;
Student a = {201803156, "홍길동" , 96.3}
```
- 멤버 접근 : 항목 연산자 '.'
```python
a.id = 30830;
a.score = 92.3;
strcpy(a.name , "Jinyoung");
``` 
- 문자형은 strcpy로 대입해야한다.
- a.name = "Jinyoung"은 오류가 생긴다.

## 구조체와 연산자
- 대입 연산자만 가능
- 다른 연산자는 사용이 불가능
  - 구조체의 비교연산 불가능
  - 구조체의 다른 대입 연산도 불가능
  - 비교연산이 필요할 경우 직접 정의해서 사용해야 한다.

# 구조체, 클래스, 객체
`-` 구조체

- 데이터를 묶는 단위로 , 상태 (멤버 변수)만 표현 가능

`-` 클래스

- 구조체를 확장한 개념으로, 상태(멤버 변수)와 행위(멤버 함수)를 모두 정의 -> 객체 생성의 기본 틀 역할
- 실제 메모리에 할당 x

`-` 객체

- 클래스를 기반으로 생성된 실체
- 프로그램 동작에 필요한 상태와 행위를 포함하는 객체를 생성하고, 이를 바탕으로 프로그램이 구동
- 실제 메모리에 할당 o

- 절차 지향적 프로그래밍으로 객체 구현 : 구조체 + 함수

# 객체 지향 프로그래밍의주요 특징
- 객체 지향프로그래밍 : 추상화 + 캡슐화 + 상속 + 다형성

 # 객체 지향적 프로그래밍으로 객체 구현
 - 구조체 데이터와 함수들을 묶는 것 -> 클래스
   - 속성 : 멤버변수 or 필드
     - char name 이런거
   - 행위 : 멤버 함수 or 메소드
     - void bark() 이런거

- 클래스 -> 객체들 -> 실체

# 클래스 선언과 활용
- 클래스 선언 : class
  - 멤버 변수와 멤버 함수를 클래스 블록에 포함

```python
class 클래스명 {
private:
    멤버변수1; # 멤버 변수는 객체의 속성을 나타낸다. 
    멤버변수2;
public:
    멤버함수1; # 멤버 함수는 객체의 동작을 나타낸다.
    멤버함수2;
};
```

- 접근 지정자
  - private : 외부에서 접근 불가
  - protected : 자식 클래스까지 접근 가능, 외부 접근불가
  - public : 누구나 접근 가능
 
- class, struct : 기본 접근 지정자만 다름
  - class : private
  - struct : public
  - 둘이 같은 것임
  - 클래스 블록이 끝나면 반드시 ;붙이기
